#!/bin/sh
#
# APST-GET : Yet Another PkgSrc Tool to manage packages.
#
# AUTHOR: pancake < pancake@phreaker.net >
# DATE: 2004/10/20
#
# depends: pkg_find, pkg_chk, pkg_tarup, awk
#

if [ -e "_etc_/apstget.conf" ]; then
. _etc_/apstget.conf
fi

# apstget.conf looks like:
#
# MAKE_TARGET="clean" # package
# INTERACTIVE="1"     # wait user for confirmations
# QUITE="1"           # Be silent in builds
# IGNORE_ERRORS="0"   # Don't stop on failed build
# UPDATE_METHOD="cvs" # cvsync|cvs|sup|cvsup
# UPDATE_ARGS=""      # UPDATE_METHOD flags
# GET_FIRST="0"       # Always get first pkg on dup packages found
# PREFERED=""         # space-separated list of prefered packages (for dup)

#----->8--------------#
PREFIX=_pfx_
MAKE=${PREFIX}/bin/bmake
PKGCHK=${PREFIX}/sbin/pkg_chk
PKGFIND=${PREFIX}/bin/pkgfind
PKGSRC_DIR=_psd_
DEFAULT_TARGETS="${DEFAULT_TARGETS}"
if [ "${MAKE_TARGET}" = "" ]; then
	MAKE_TARGET="clean"
fi
if [ "${INTERACTIVE}" = "" ]; then
	INTERACTIVE="1"
fi
if [ "${IGNORE_ERRORS}" = "" ]; then
	IGNORE_ERRORS="0"
fi
if [ "${UPDATE_METHOD}" = "" ]; then
	UPDATE_METHOD="cvs"
fi
if [ "${GET_FIRST}" = "" ]; then
	GET_FIRST="0"
fi
if [ "${UPDATE_METHOD}" = "cvs" ]; then
	if [ "${UPDATE_ARGS}" = "" ]; then
	UPDATE_ARGS="-z 3"
	fi
fi
case "${QUITE}" in
"1") QUITE="/dev/null";   QUITE2="/dev/stderr" ;;
"2") QUITE="/dev/null";   QUITE2="/dev/null"   ;;
*)   QUITE="/dev/stdout"; QUITE2="/dev/stderr" ;;
esac

if [ ! -e "/dev/stdin" ]; then
	echo "/dev/stdin doesn't exist. Please create the device first."
fi
if [ ! -e "/dev/stderr" ]; then
	echo "/dev/stderr doesn't exist. Please create the device first."
fi

process_failed () {
	if [ "${IGNORE_ERRORS}" = "0" ]; then
		exit 1;
	fi
}

press_any_key () {
	if [ "${INTERACTIVE}" = "1" ]; then
		echo "==> Press Ctrl-C to cancel, any other key to proceed."
		read ME
	fi
}

do_usage() {
	echo "Usage $1 [action] [targets...]"
	echo "actions:"
	echo "  install      - install/update selected packages."
	echo "  upgrade      - update the selected packages and solves dependencies."
	echo "  dist-upgrade - update the entire system."
	echo "  remove       - remove the selected packages."
	echo "  update       - update the pkgsrc/-wip tree."
	echo "  relink       - try to solve all broken libs."
	echo "  clean        - clean all build directories."
	echo ""
	echo "variables (environ|_etc_/apstget.conf):"
	echo "  MAKE_TARGET, INTERACTIVE, QUITE, IGNORE_ERRORS"
	echo "  UPDATE_METHOD, UPDATE_ARGS, GET_FIRST, PREFERED"
}

do_install() {
	PKG=$1
	DIR=$1
	UPD=$2 # Update flag
	if [ "`echo $PKG | grep /`" = "" ]; then
		DIR=`${PKGFIND} -qx $PKG`
	else
		PKG=`echo $PKG | awk -F / '{ print $2 }'`
	fi

	if [ "${GET_FIRST}" = "1" ]; then
		DIR=`echo ${DIR} | awk '{print $1}'`
	else 
		for A in `echo ${PREFERED}`; do
			for B in ${DIR} ; do
			if [ "${A}" = "${B}" ]; then
				DIR=${A}
				echo "==> Using prefered ${A}"
				break;
			fi
			done
		done
	fi
	if [ ! -e "${PKGSRC_DIR}/${DIR}" ]; then
		if [ "`echo ${DIR}|awk '{print $2}'`" = "" ]; then
			echo "==> Error! The package $PKG was not found!"
		else
			echo "==> ${PKG} is in more than one category. Specify it:"
			echo "==> You can also use GET_FIRST or PREFERED"
			echo "==> Found at: `echo ${DIR}`"
		fi
	else
	STAT="`echo $DIR | ${PKGCHK} -C /dev/stdin -c`"
	if [ "${STAT}" = "" ]; then
		echo "==> Package ${DIR} is at the latest version"
	else
	echo "==> Preparing installation for $DIR"
	cd ${PKGSRC_DIR}/${DIR}
	DEPS=`${MAKE} show-all-depends-dirs`
	REPLACE=""
	INSTALL=""
	for A in ${DEPS} ; do
		CHK=`echo ${A} | ${PKGCHK} -C /dev/stdin -c`
		if [ ! "`echo ${CHK}|grep missing`" = "" ]; then
			echo " [i] Enqueueing for install ${A}"
			INSTALL="${INSTALL} ${A}"
		else
		if [ ! "`echo ${CHK}| grep mismatch`" = "" ]; then
			echo " [u] Need to update ${A}"
			if [ "${UPD}" = "1" ]; then
				REPLACE="${REPLACE} ${A}"
			else
			if [ "${A}" = "${DIR}" ]; then
				REPLACE="${REPLACE} ${A}"
				fi
			fi;fi
		fi
	done
	fi
	# replace list
	if [ ! "${REPLACE}" = "" ]; then
	for A in ${REPLACE}; do
		echo "==> Upgrading ${A}..."
		cd ${PKGSRC_DIR}/${A}
		${MAKE} replace ${UD_TARGETS} > ${QUITE} 2>${QUITE2}
		if [ ! "$?" = "0" ]; then
			echo "==> Error occurred at ${DIR}."
			process_failed
		else
			echo "==> Process finished."
		fi
	done
	fi

	# install list
	if [ ! "${INSTALL}" = "" ]; then
	for A in ${INSTALL}; do
		echo "==> Installing ${A}"
		cd ${PKGSRC_DIR}/${A}
		${MAKE} install ${UD_TARGETS} > ${QUITE} 2>${QUITE2}
		if [ ! "$?" = "0" ]; then
			echo "==> Error occurred at ${DIR}."
			process_failed
		else
			echo "==> Process finished."
		fi
	done
	fi

	fi # check installed
}

do_remove() {
	PKG=$1
	DIR=$1
	if [ "`echo $PKG | grep /`" = "" ]; then
		DIR=`${PKGFIND} -qx $PKG`
	else
		PKG=`echo $PKG | awk -F / '{ print $2 }'`
	fi

	FOUND="`pkg_info ${PKG} 2>/dev/null`"
	if [ "${FOUND}" = "" ]; then
	echo "==> Package $PKG not installed."
	else
		LIST="`pkg_delete -n ${PKG}`"
		DEIN="`echo ${LIST} | grep DEINSTALL`"

		pkg_delete -n ${PKG} | grep -v DEINSTALL | grep delete
		echo ""
		if [ ! "${DEIN}" = "" ]; then
		echo "==> Use 'pkg_info -k ${PKG} | more' to see the DEINSTALL script"
		fi

		press_any_key

		echo "==> Performing remove for $PKG..."
		pkg_delete "${PKG}"
	fi
}

do_update() {
	PKS=""
	WIP=""
	for A in $1 $2 ; do
		case $A in
		"pkgsrc") PKS="1";;
		"wip")    WIP="1";;
		esac
	done
	if [ "${PKS}${WIP}" = "" ]; then
		PKS="1"
		WIP="1"
	fi

	if [ "$PKS" = "1" ]; then
		CMD="${UPDATE_METHOD} ${UPDATE_ARGS}"
		echo "==> Updating pkgsrc tree using ${CMD}..."
		cd ${PKGSRC_DIR}
		if [ "${UPDATE_METHOD}" = "cvs" ]; then
			cvs ${UPDATE_ARGS} -q update -dP
		else
			${UPDATE_METHOD} ${UPDATE_ARGS}
		fi
	fi

	if [ "$WIP" = "1" ]; then
		if [ -e "${PKGSRC_DIR}/wip" ]; then
		echo "==> Updating pkgsrc-wip tree..."
		cd ${PKGSRC_DIR}/wip
		cvs -z 3 -q update -dP
		fi
	fi
}

do_clean() {
	WRKOBJDIR="`grep -e WRKOBJDIR /etc/mk.conf|awk -F = '{ print $2; }'`"
	if [ -z "${WRKOBJDIR}" ]; then
		echo "==> WRKOBJDIR not defined in mk.conf"
		cd ${PKGSRC_DIR}
		printf "==> Scanning pkgsrc tree for dirty dirs... "
	PKGTOCLEAN=`find . | grep work | awk -F / '{print $2"/"$3; }'|uniq`
		echo "DONE"
	else
		echo "Using WRKOBJDIR=${WRKOBJDIR}"
		cd ${WRKOBJDIR}
		PKGTOCLEAN=`echo */*`;
	fi

	echo "==> Cleaning all dirty builds..."
	for A in ${PKGTOCLEAN} ; do
		if [ ! -e ${PKGSRC_DIR}/${A} ]; then continue ; fi
		cd ${PKGSRC_DIR}/${A}
		printf "${A}   "
		${MAKE} clean > /dev/null 2>&1
		echo "OK"
	done
	echo "DONE"

}

do_relink() {
	if [ "$1" = "" ]; then
	echo "==> Looking for broken libs on ${PREFIX}[/bin|/sbin|/lib]"
		FILES=`find ${PREFIX}/bin ${PREFIX}/sbin ${PREFIX}/lib -type f`
	else
	echo "==> Looking for unlinked binaries of package ${1}"
		FILES=`pkg_info -L $1 | grep bin`
	fi

	for A in ${FILES}; do
		LIB=`ldd ${A} 2>/dev/null |grep found|awk -F = '{ print $1 }'`
		for B in ${LIB}; do
		#--
		echo "==> Relinking ${B}..."
		COW="`echo ${B} |awk -F so '{ print $1 }'`so"
		TARGET="`ls -l ${PREFIX}/lib/${COW}.* 2>/dev/null | grep -e ^- `"
		if [ "${TARGET}" = "" ]; then
			echo " * Unable to be resolved"
		else
			TARGET=`echo ${TARGET} | awk '{ print $9 }'`
			echo " * Solved against ${TARGET}"
			ln -s ${TARGET} ${PREFIX}/lib/$B
		fi
		#--		
		done
	done
}

# Main procedure

case "$1" in
"")
	do_usage $0
	;;
"install"|"upgrade")
	FLAG=0
	if [ "${2}" = "" ]; then
		echo "You must give me at least one package"
		exit 1
	fi
	if [ "$1" = "upgrade" ]; then
		FLAG=1
	fi
	while : ; do
		do_install $2 ${FLAG}
		shift;
		if [ "$2" = "" ]; then
		break;
		fi
	done
	;;
"remove")
	if [ "${2}" = "" ]; then
		echo "You must give me at least one package"
		exit 1
	fi
	while : ; do
		do_remove $2
		shift;
		if [ "$2" = "" ]; then
		break;
		fi
	done
	;;
"update")
	do_update $1 $2
	;;
"dist-upgrade")
	echo "==> Generating the update list..."
	LIST=`${PKGCHK} -i | grep mismatch | \
		awk -F '([.\-]*)-[0-9]' '{print $1 }'|grep -v WARNING`
		
	if [ "${LIST}" = "" ]; then
		echo "Your system is completely updated"
	else
	echo "Upgrade list:"
	echo ${LIST}

	press_any_key

	for A in ${LIST}; do
		echo "==> Updating ${A}..."
		do_install ${A} 1
	done
	fi
	;;
"clean")
	do_clean
	;;
"relink")
	while : ; do
		do_relink $2
		shift;
		if [ "$2" = "" ]; then
		break;
		fi
	done
	;;
*)
	do_usage $0
	;;
esac

