#!/bin/sh
#
# APST-GET : Yet Another PkgSrc Tool to manage packages.
#
# AUTHOR: pancake < pancake@phreaker.net >
# DATE: 2004/11/10
#
# depends: pkg_find, pkg_tarup, awk, pkglint
#

if [ -e "_etc_/apstget.conf" ]; then
. _etc_/apstget.conf
fi

# apstget.conf looks like:
#
# 
# CLEAN_BUILD="1"     # clean before and after every build
# PACKAGE_BUILD="0"   # build packages
# INTERACTIVE="1"     # wait user for confirmations
# QUITE="1"           # Be silent in builds
# SKIP_LICENSES="0"   # Ignore LICENSES
# IGNORE_ERRORS="0"   # Don't stop on failed build
# UPDATE_METHOD="cvs" # cvsync|cvs|sup|cvsup
# UPDATE_ARGS=""      # UPDATE_METHOD flags
# GET_FIRST="0"       # Always get first pkg on dup packages found
# PREFERED=""         # space-separated list of prefered packages (for dup)

#----->8--------------#
MAKEFLAG="PKG_RESUME_TRANSFERS=YES" # make this as default
PREFIX=_pfx_
MAKE=_makebin_
PKGFIND=${PREFIX}/bin/pkgfind
PKGCHK=${PREFIX}/sbin/pkg_chk
PKGSRC_DIR=_psd_
DEFAULT_TARGETS="${DEFAULT_TARGETS}"
if [ "${CLEAN_BUILD}" = "" ]; then
	CLEAN_BUILD="1"
fi
if [ "${INTERACTIVE}" = "" ]; then
	INTERACTIVE="1"
fi
if [ "${IGNORE_ERRORS}" = "" ]; then
	IGNORE_ERRORS="0"
fi
if [ "${UPDATE_METHOD}" = "" ]; then
	UPDATE_METHOD="cvs"
fi
if [ "${GET_FIRST}" = "" ]; then
	GET_FIRST="0"
fi
if [ "${UPDATE_METHOD}" = "cvs" ]; then
	if [ "${UPDATE_ARGS}" = "" ]; then
	UPDATE_ARGS="-z 3"
	fi
fi
WRAPPER=_pfx_/libexec/apstget-wrapper

if [ ! -e "/dev/stdin" ]; then
	echo "/dev/stdin doesn't exist. Please create the device first."
fi
if [ ! -e "/dev/stderr" ]; then
	echo "/dev/stderr doesn't exist. Please create the device first."
fi

do_make_clean () {
	if [ "${CLEAN_BUILD}" = "1" ]; then
		echo "==> Cleaning..."
		${MAKE} clean
	fi
}

do_make_package () {
	if [ "${PACKAGE_BUILD}" = "1" ]; then
		echo "==> Generating package..."
		env PACKAGE_NOINSTALL=YES ${MAKE} ${MAKEFLAG} package
	fi
}

process_failed () {
	if [ "${IGNORE_ERRORS}" = "0" ]; then
		exit 1;
	fi
}

press_any_key () {
	if [ "${INTERACTIVE}" = "1" ]; then
		echo "==> Press Ctrl-C to cancel, any other key to proceed."
		read ME
	fi
}

do_usage() {
	echo "Usage $1 [action] [targets...]"
	echo "actions:"
	echo "  install      - install/update selected packages."
	echo "  upgrade      - update the selected packages and solves dependencies."
	echo "  dist-upgrade - update the entire system."
	echo "  remove       - remove the selected packages."
	echo "  update       - update the pkgsrc/-wip tree."
	echo "  relink       - try to solve all broken libs."
	echo "  clean        - clean all build directories."
	echo "  autoclean    - remove all outdated distfiles."
	echo "  orphan       - list orphaned packages."
	echo ""
	echo "variables (environ|_etc_/apstget.conf):"
	echo "  CLEAN_BUILD=1, INTERACTIVE=1, QUITE=0, IGNORE_ERRORS=0"
	echo "  UPDATE_METHOD=cvs, UPDATE_ARGS, GET_FIRST=0, PREFERED"
	echo "  BUILD_PACKAGES=0, SKIP_LICENSES=0"
}

check_version() {
	cPKG=$1
	cDIR=$1
	if [ ! "${cDIR}" = "" ]; then
	if [ "`echo $cPKG | grep /`" = "" ]; then
		cDIR=`${PKGFIND} -qx $cPKG`
	else
		cPKG=`echo $cPKG | awk -F / '{ print $2 }'`
	fi
		cd ${PKGSRC_DIR}/${cDIR}/
		cPKG=`${MAKE} show-var VARNAME=PKGNAME | awk -F '([.\-]*)-[0-9]' '{print $1 }'`
		IVER=`pkg_info -e $cPKG`
		if [ "$?" = "1" ]; then
			echo "missing"
		else
			cd ${PKGSRC_DIR}/${cDIR}
			DVER=`${MAKE} show-var VARNAME=PKGNAME 2> /dev/null`
			if [ ! "${DVER}" = "${IVER}" ]; then
				echo "from ${IVER} to ${DVER}"
			fi
		fi

	fi
}

do_relink() {
	if [ "$1" = "" ]; then
	echo "==> Looking for broken libs on ${PREFIX}[/bin|/sbin|/lib]"
		FILES=`find ${PREFIX}/bin ${PREFIX}/sbin ${PREFIX}/lib -type f`
	else
		lPKG=$1
		if [ !  "`echo $1 |grep /`" = "" ]; then
			cd ${PKGSRC_DIR}/$1
			lPKG="`${MAKE} show-var VARNAME=PKGNAME`"
		fi
		echo "==> Looking for unlinked binaries in package ${lPKG}"
		FILES=`pkg_info -L $lPKG | grep -e bin -e lib`
	fi

	for A in ${FILES}; do
		LIB=`ldd ${A} 2>/dev/null |grep found|awk -F = '{ print $1 }'`
		for B in ${LIB}; do
		#--
		OK="1"
		for C in ${UNRESOLVED} ; do
			if [ "${C}" = "${B}" ]; then
				OK="0"
			fi
		done
		if [ "${OK}" = "1" ]; then
		echo "==> Relinking ${B}..."
		COW="`echo ${B} |awk -F so '{ print $1 }'`so"
		TARGET="`ls -l ${PREFIX}/lib/${COW}.* 2>/dev/null | grep -e ^- `"
		if [ "${TARGET}" = "" ]; then
			echo " * Unable to be resolved"
			UNRESOLVED="${UNRESOLVED} ${B}"
		else
			TARGET=`echo ${TARGET} | awk '{ print $9 }'`
			echo " * Solved against ${TARGET}"
			ln -s ${TARGET} ${PREFIX}/lib/$B
		fi
		#--		
		fi
		done
	done
}


do_auto_relink() {
	rPKG=$1
	if [ ! "`echo $1| grep /`" = "" ]; then
		rPKG=`echo $1 | awk -F / '{ print $2 }'`
	fi
	rPKGS=`pkg_info -qR ${rPKG}`
	echo "==> Doing automatic relink for inverse deps of ${rPKG}"
	for A in ${rPKGS} ; do
		do_relink ${A}
	done
}

do_install() {
	PKG=$1
	DIR=$1
	UPD=$2 # Update flag
	if [ "`echo $PKG | grep /`" = "" ]; then
		DIR=`${PKGFIND} -qx $PKG`
		if [ "${DIR}" = "" ]; then
			DIR=NOTFOUND
		fi
	else
		PKG=`echo $PKG | awk -F / '{ print $2 }'`
	fi

	if [ "${GET_FIRST}" = "1" ]; then
		DIR=`echo ${DIR} | awk '{print $1}'`
	else 
		for A in `echo ${PREFERED}`; do
			for B in ${DIR} ; do
			if [ "${A}" = "${B}" ]; then
				DIR=${A}
				echo "==> Using prefered ${A}"
				break;
			fi
			done
		done
	fi

	if [ ! -e "${PKGSRC_DIR}/${DIR}" ]; then
		if [ "`echo ${DIR}|awk '{print $2}'`" = "" ]; then
			echo "==> Error! The package $PKG was not found!"
		else
			echo "==> ${PKG} is in more than one category. Specify it:"
			echo "==> You can also use GET_FIRST or PREFERED"
			echo "==> Found at: `echo ${DIR}`"
		fi
	else

	STAT="`check_version $DIR`"
	if [ "${STAT}" = "" ]; then
		echo "==> Package ${DIR} is at the latest version"
	else
	echo "==> Preparing installation for $DIR"
	cd ${PKGSRC_DIR}/${DIR}
	DEPS=`${MAKE} ${MAKEFLAG} show-depends-dirs`
	DEPS="${DEPS} ${DIR}"
	REPLACE=""
	INSTALL=""
	for A in ${DEPS} ; do
		CHK=`check_version ${A}`
		if [ ! "${CHK}" = "" ]; then
		if [ ! "`echo ${CHK}|grep missing`" = "" ]; then
			echo " [i] Enqueueing for install ${A}"
			INSTALL="${INSTALL} ${A}"
		else
		if [ ! "`echo ${CHK}| grep from`" = "" ]; then
			echo " [u] Need to update ${A} ${CHK}"
			if [ "${UPD}" = "1" ]; then
				REPLACE="${REPLACE} ${A}"
			else
			if [ "${A}" = "${DIR}" ]; then
				REPLACE="${REPLACE} ${A}"
				fi
			fi;fi
		  fi
		fi
		# Add new deps
		cd ${PKGSRC_DIR}/${A}
		if [ "${SKIP_LICENSES}" = "1" ];then
		ACCEPTABLE_LICENSES="`cat Makefile | grep LICENSE \
			|awk -F = '{ print $2 }'`"
			MAKEFLAG="${MAKEFLAG} ACCEPTABLE_LICENSES=${ACCEPTABLE_LICENSES}"
		echo "==> Skipping license: ${ACCEPTABLE_LICENSE}"
		fi
		DEPS2=`${MAKE} ${MAKEFLAG} show-depends-dirs`
		for B in ${DEPS2} ; do
			if [ "`echo ${DEPS} | grep ${B}`" = "" ]; then
				DEPS="${DEPS} ${B}"
			fi
		done
	done
	fi

	# replace list
	if [ ! "${REPLACE}" = "" ]; then
	for A in ${REPLACE}; do
		echo "==> Upgrading ${A}..."
		cd ${PKGSRC_DIR}/${A}
		${MAKE} ${MAKEFLAG} fetch
		do_make_clean
		${MAKE} ${MAKEFLAG} replace ${UD_TARGETS} | ${WRAPPER} 2>&1
		do_make_package
		do_make_clean
		if [ ! "$?" = "0" ]; then
			echo "==> Error occurred at ${DIR}."
			process_failed
		else
			echo "==> Process finished."
			do_auto_relink ${A}
		fi
	done
	fi

	# install list
	if [ ! "${INSTALL}" = "" ]; then
	for A in ${INSTALL}; do
		echo "==> Installing ${A}"
		cd ${PKGSRC_DIR}/${A}
		${MAKE} ${MAKEFLAG} fetch
		do_make_clean
		${MAKE} ${MAKEFLAG} install ${UD_TARGETS} | ${WRAPPER} 2>&1
		do_make_package
		do_make_clean
		if [ ! "$?" = "0" ]; then
			echo "==> Error occurred at ${DIR}."
			process_failed
		else
			echo "==> Process finished."
		fi
	done
	fi

	fi # check installed
}

do_remove() {
	PKG=$1
	DIR=$1
	if [ "`echo $PKG | grep /`" = "" ]; then
		DIR=`${PKGFIND} -qx $PKG`
	else
		PKG=`echo $PKG | awk -F / '{ print $2 }'`
	fi

	FOUND="`pkg_info ${PKG} 2>/dev/null`"
	if [ "${FOUND}" = "" ]; then
	echo "==> Package $PKG not installed."
	else
		LIST="`pkg_delete -n ${PKG}`"
		DEIN="`echo ${LIST} | grep DEINSTALL`"

		pkg_delete -n ${PKG} | grep -v DEINSTALL | grep delete
		echo ""
		if [ ! "${DEIN}" = "" ]; then
		echo "==> Use 'pkg_info -k ${PKG} | more' to see the DEINSTALL script"
		fi

		press_any_key

		echo "==> Performing remove for $PKG..."
		pkg_delete "${PKG}"
	fi
}

do_update() {
	PKS=""
	WIP=""
	for A in $1 $2 ; do
		case $A in
		"pkgsrc") PKS="1";;
		"wip")    WIP="1";;
		esac
	done
	if [ "${PKS}${WIP}" = "" ]; then
		PKS="1"
		WIP="1"
	fi

	if [ "$PKS" = "1" ]; then
		CMD="${UPDATE_METHOD} ${UPDATE_ARGS}"
		echo "==> Updating pkgsrc tree using ${CMD}..."
		cd ${PKGSRC_DIR}
		if [ "${UPDATE_METHOD}" = "cvs" ]; then
			cvs ${UPDATE_ARGS} -q update -dP
		else
			${UPDATE_METHOD} ${UPDATE_ARGS}
		fi
	fi

	if [ "$WIP" = "1" ]; then
		if [ -e "${PKGSRC_DIR}/wip" ]; then
		echo "==> Updating pkgsrc-wip tree..."
		cd ${PKGSRC_DIR}/wip
		cvs -z 3 -q update -dP
		fi
	fi
}

do_clean() {
	WRKOBJDIR="`grep -e WRKOBJDIR /etc/mk.conf|awk -F = '{ print $2; }'`"
	if [ -z "${WRKOBJDIR}" ]; then
		echo "==> WRKOBJDIR not defined in mk.conf"
		cd ${PKGSRC_DIR}
		printf "==> Scanning pkgsrc tree for dirty dirs... "
	PKGTOCLEAN=`find . | grep work | awk -F / '{print $2"/"$3; }'|uniq`
		echo "DONE"
	else
		echo "Using WRKOBJDIR=${WRKOBJDIR}"
		cd ${WRKOBJDIR}
		PKGTOCLEAN=`echo */*`;
	fi

	echo "==> Cleaning all dirty builds..."
	for A in ${PKGTOCLEAN} ; do
		if [ ! -e ${PKGSRC_DIR}/${A} ]; then continue ; fi
		cd ${PKGSRC_DIR}/${A}
		printf "${A}   "
		${MAKE} clean > /dev/null 2>&1
		echo "OK"
	done
	echo "DONE"

}

# Main procedure

case "$1" in
"")
	do_usage $0
	;;
"install"|"upgrade")
	FLAG=0
	if [ "${2}" = "" ]; then
		echo "You must give me at least one package"
		exit 1
	fi
	if [ "$1" = "upgrade" ]; then
		FLAG=1
	fi
	while : ; do
		do_install $2 ${FLAG}
		shift;
		if [ "$2" = "" ]; then
		break;
		fi
	done
	;;
"remove")
	if [ "${2}" = "" ]; then
		echo "You must give me at least one package"
		exit 1
	fi
	while : ; do
		do_remove $2
		shift;
		if [ "$2" = "" ]; then
		break;
		fi
	done
	;;
"update")
	do_update $1 $2
	;;
"dist-upgrade")
	echo "==> Generating the update list..."
	LIST=`${PKGCHK} -i | grep mismatch | \
		awk -F '([.\-]*)-[0-9]' '{print $1 }'|grep -v WARNING`
		
	if [ "${LIST}" = "" ]; then
		echo "Your system is completely updated"
	else
	echo "Upgrade list:"
	echo ${LIST}

	press_any_key

	for A in ${LIST}; do
		echo "==> Updating ${A}..."
		do_install ${A} 1
	done
	fi
	;;
"clean")
	if [ "$2" = "" ]; then
		do_clean
	else
		while : ; do
		PKG=$2
		if [ "`echo $PKG | grep /`" = "" ]; then
			DIR=`${PKGFIND} -qx $PKG`
			if [ "${DIR}" = "" ]; then
				DIR=NOTFOUND
			fi
		else
			PKG=`echo $PKG | awk -F / '{ print $2 }'`
		fi
		if [ -d "${PKGSRC_DIR}/${DIR}" ]; then
			cd ${PKGSRC_DIR}/${DIR}
			${MAKE} clean
		else
			echo "Directory for $2 not found."
		fi
		# next one
		shift;
		if [ "$2" = "" ]; then break; fi
		done
	fi
	;;
"autoclean")
	lintpkgsrc -r
	;;
"relink")
	while : ; do
		do_relink $2
		shift;
		if [ "$2" = "" ]; then break; fi
	done
	;;
"orphan")
	PKG=`pkg_info -a| awk '{ print $1 }' | grep -e lib `
	for A in $PKG ; do
		COW=`pkg_delete -nRr ${A}| grep deinstalling`
		if [ "${COW}" = "" ]; then
			echo $A
		fi
	done
	;;
*)
	do_usage $0
	;;
esac

