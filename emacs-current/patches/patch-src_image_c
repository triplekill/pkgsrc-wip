$NetBSD$

mage.c:7417:7: error: too few arguments to function 'DGifCloseFile'
emacs-current/work/.buildlink/include/gif_lib.h:183:9:
note: declared here

--- src/image.c	2014-05-04 18:51:32 +0000
+++ src/image.c	2014-06-17 14:50:54 +0000
@@ -7255,7 +7255,11 @@ gif_image_p (Lisp_Object object)
 #ifdef WINDOWSNT
 
 /* GIF library details.  */
+#if 5 < GIFLIB_MAJOR + (1 <= GIFLIB_MINOR)
+DEF_IMGLIB_FN (int, DGifCloseFile, (GifFileType *, int *));
+#else
 DEF_IMGLIB_FN (int, DGifCloseFile, (GifFileType *));
+#endif
 DEF_IMGLIB_FN (int, DGifSlurp, (GifFileType *));
 #if GIFLIB_MAJOR < 5
 DEF_IMGLIB_FN (GifFileType *, DGifOpen, (void *, InputFunc));
@@ -7325,6 +7329,19 @@ gif_read_from_memory (GifFileType *file,
   return len;
 }
 
+static int
+gif_close (GifFileType *gif, int *err)
+{
+  int retval;
+
+#if 5 < GIFLIB_MAJOR + (1 <= GIFLIB_MINOR)
+  retval = fn_DGifCloseFile (gif, err);
+#else
+  retval = fn_DGifCloseFile (gif);
+  if (err)
+    *err = gif->Error;
+#endif
+}
 
 /* Load GIF image IMG for use on frame F.  Value is true if
    successful.  */
@@ -7419,7 +7436,7 @@ gif_load (struct frame *f, struct image 
   if (!check_image_size (f, gif->SWidth, gif->SHeight))
     {
       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
-      fn_DGifCloseFile (gif);
+      gif_close (gif, NULL);
       return 0;
     }
 
@@ -7428,7 +7445,7 @@ gif_load (struct frame *f, struct image 
   if (rc == GIF_ERROR || gif->ImageCount <= 0)
     {
       image_error ("Error reading `%s'", img->spec, Qnil);
-      fn_DGifCloseFile (gif);
+      gif_close (gif, NULL);
       return 0;
     }
 
@@ -7440,7 +7457,7 @@ gif_load (struct frame *f, struct image 
       {
 	image_error ("Invalid image number `%s' in image `%s'",
 		     image_number, img->spec);
-	fn_DGifCloseFile (gif);
+	gif_close (gif, NULL);
 	return 0;
       }
   }
@@ -7458,7 +7475,7 @@ gif_load (struct frame *f, struct image 
   if (!check_image_size (f, width, height))
     {
       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
-      fn_DGifCloseFile (gif);
+      gif_close (gif, NULL);
       return 0;
     }
 
@@ -7476,7 +7493,7 @@ gif_load (struct frame *f, struct image 
 	     && 0 <= subimg_left && subimg_left <= width - subimg_width))
 	{
 	  image_error ("Subimage does not fit in image", Qnil, Qnil);
-	  fn_DGifCloseFile (gif);
+	  gif_close (gif, NULL);
 	  return 0;
 	}
     }
@@ -7484,7 +7501,7 @@ gif_load (struct frame *f, struct image 
   /* Create the X image and pixmap.  */
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     {
-      fn_DGifCloseFile (gif);
+      gif_close (gif, NULL);
       return 0;
     }
 
@@ -7655,7 +7672,18 @@ gif_load (struct frame *f, struct image 
 			    Fcons (make_number (gif->ImageCount),
 				   img->lisp_data));
 
-  fn_DGifCloseFile (gif);
+  if (gif_close (gif, &gif_err) == GIF_ERROR)
+    {
+#if 5 <= GIFLIB_MAJOR
+      char *error_text = fn_GifErrorString (gif_err);
+
+      if (error_text)
+	image_error ("Error closing `%s': %s",
+		     img->spec, build_string (error_text));
+#else
+      image_error ("Error closing `%s'", img->spec);
+#endif
+    }
 
   /* Maybe fill in the background field while we have ximg handy. */
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
