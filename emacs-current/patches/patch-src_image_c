$NetBSD$

mage.c:7417:7: error: too few arguments to function 'DGifCloseFile'
emacs-current/work/.buildlink/include/gif_lib.h:183:9:
note: declared here

--- src/image.c.orig	2014-06-15 09:25:05.000000000 +0900
+++ src/image.c	2014-06-17 08:46:30.000000000 +0900
@@ -7410,12 +7410,20 @@ gif_load (struct frame *f, struct image 
 #endif
     }
 
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)  
+  int * return_value_p;
+#endif
   /* Before reading entire contents, check the declared image size. */
   if (!check_image_size (f, gif->SWidth, gif->SHeight))
     {
       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+      fn_DGifCloseFile (gif, return_value_p);
+      return *return_value_p;
+#else
       fn_DGifCloseFile (gif);
       return 0;
+#endif
     }
 
   /* Read entire contents.  */
@@ -7423,8 +7431,13 @@ gif_load (struct frame *f, struct image 
   if (rc == GIF_ERROR || gif->ImageCount <= 0)
     {
       image_error ("Error reading `%s'", img->spec, Qnil);
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+      fn_DGifCloseFile (gif, return_value_p);
+      return *return_value_p;
+#else
       fn_DGifCloseFile (gif);
       return 0;
+#endif
     }
 
   /* Which sub-image are we to display?  */
@@ -7435,8 +7448,13 @@ gif_load (struct frame *f, struct image 
       {
 	image_error ("Invalid image number `%s' in image `%s'",
 		     image_number, img->spec);
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+      fn_DGifCloseFile (gif, return_value_p);
+      return *return_value_p;
+#else
 	fn_DGifCloseFile (gif);
 	return 0;
+#endif
       }
   }
 
@@ -7453,8 +7471,13 @@ gif_load (struct frame *f, struct image 
   if (!check_image_size (f, width, height))
     {
       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+      fn_DGifCloseFile (gif, return_value_p);
+      return *return_value_p;
+#else
       fn_DGifCloseFile (gif);
       return 0;
+#endif
     }
 
   /* Check that the selected subimages fit.  It's not clear whether
@@ -7471,16 +7494,26 @@ gif_load (struct frame *f, struct image 
 	     && 0 <= subimg_left && subimg_left <= width - subimg_width))
 	{
 	  image_error ("Subimage does not fit in image", Qnil, Qnil);
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+	  fn_DGifCloseFile (gif, return_value_p);
+	  return *return_value_p;
+#else
 	  fn_DGifCloseFile (gif);
 	  return 0;
+#endif
 	}
     }
 
   /* Create the X image and pixmap.  */
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     {
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+      fn_DGifCloseFile (gif, return_value_p);
+      return *return_value_p;
+#else
       fn_DGifCloseFile (gif);
       return 0;
+#endif
     }
 
   /* Clear the part of the screen image not covered by the image.
@@ -7650,7 +7683,11 @@ gif_load (struct frame *f, struct image 
 			    Fcons (make_number (gif->ImageCount),
 				   img->lisp_data));
 
+#if (GIFLIB_MAJOR == 5) && (GIFLIB_MINOR > 0)
+  fn_DGifCloseFile (gif, return_value_p);
+#else
   fn_DGifCloseFile (gif);
+#endif
 
   /* Maybe fill in the background field while we have ximg handy. */
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
