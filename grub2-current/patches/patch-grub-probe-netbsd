Description: adds support for NetBSD in GRUB utilities.
See: http://lists.gnu.org/archive/html/grub-devel/2009-12/msg00432.html

Change log
----------
2010-??-??  Gregoire Sutre  <gregoire.sutre@labri.fr>

	Add grub-probe support for NetBSD.

	* util/getroot.c (find_root_device): Convert block device to
	character device on NetBSD.
	* util/probe.c (probe): Require character device on NetBSD.
	* util/hostdisk.c (grub_util_biosdisk_open): NetBSD specific code.
	(convert_system_partition_to_system_disk): Likewise.
	(grub_util_biosdisk_get_grub_dev): Likewise.
	(make_device_name): Fixed a typo in bsd_part_str.

--- util/getroot.c.orig	2010-01-02 14:42:38.000000000 +0100
+++ util/getroot.c
@@ -264,10 +264,17 @@ find_root_device (const char *dir, dev_t
 	  /* Found!  */
 	  char *res;
 	  char *cwd;
+#if defined(__NetBSD__)
+	  /* Convert this block device to its character (raw) device.  */
+	  const char *template = "%s/r%s";
+#else
+	  /* Keep the device name as it is.  */
+	  const char *template = "%s/%s";
+#endif
 
 	  cwd = xgetcwd ();
-	  res = xmalloc (strlen (cwd) + strlen (ent->d_name) + 2);
-	  sprintf (res, "%s/%s", cwd, ent->d_name);
+	  res = xmalloc (strlen (cwd) + strlen (ent->d_name) + 3);
+	  sprintf (res, template, cwd, ent->d_name);
 	  strip_extra_slashes (res);
 	  free (cwd);
 
--- util/grub-probe.c.orig	2010-01-02 14:42:38.000000000 +0100
+++ util/grub-probe.c
@@ -111,7 +111,7 @@ probe (const char *path, char *device_na
 
   if (path == NULL)
     {
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
       if (! grub_util_check_char_device (device_name))
         grub_util_error ("%s is not a character device.\n", device_name);
 #else
--- util/hostdisk.c.orig	2010-01-02 14:42:38.000000000 +0100
+++ util/hostdisk.c
@@ -97,6 +97,17 @@ struct hd_geometry
 # include <sys/disk.h>
 #endif
 
+#if defined(__NetBSD__)
+# include <sys/ioctl.h>
+# include <sys/disklabel.h>    /* struct disklabel */
+# ifdef HAVE_GETRAWPARTITION
+#  include <util.h>    /* getrawpartition */
+# endif /* HAVE_GETRAWPARTITION */
+# ifndef RAW_FLOPPY_MAJOR
+#  define RAW_FLOPPY_MAJOR	9
+# endif /* ! RAW_FLOPPY_MAJOR */
+#endif
+
 struct
 {
   char *drive;
@@ -191,16 +202,20 @@ grub_util_biosdisk_open (const char *nam
     return GRUB_ERR_NONE;
   }
 #elif defined(__linux__) || defined(__CYGWIN__) || defined(__FreeBSD__) || \
-      defined(__FreeBSD_kernel__) || defined(__APPLE__)
+      defined(__FreeBSD_kernel__) || defined(__APPLE__) || defined(__NetBSD__)
   {
+# if defined(__NetBSD__)
+    struct disklabel label;
+# else
     unsigned long long nr;
+# endif
     int fd;
 
     fd = open (map[drive].device, O_RDONLY);
     if (fd == -1)
       return grub_error (GRUB_ERR_BAD_DEVICE, "cannot open `%s' while attempting to get disk size", map[drive].device);
 
-# if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__APPLE__)
+# if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__APPLE__) || defined(__NetBSD__)
     if (fstat (fd, &st) < 0 || ! S_ISCHR (st.st_mode))
 # else
     if (fstat (fd, &st) < 0 || ! S_ISBLK (st.st_mode))
@@ -214,6 +229,11 @@ grub_util_biosdisk_open (const char *nam
     if (ioctl (fd, DIOCGMEDIASIZE, &nr))
 # elif defined(__APPLE__)
     if (ioctl (fd, DKIOCGETBLOCKCOUNT, &nr))
+# elif defined(__NetBSD__)
+    /* Do not attempt to read from a floppy device as it may take a long
+       time before aborting if there is no floppy in the drive.  */
+    if ((major(st.st_rdev) == RAW_FLOPPY_MAJOR) ||
+	ioctl (fd, DIOCGDINFO, &label))
 # else
     if (ioctl (fd, BLKGETSIZE64, &nr))
 # endif
@@ -224,14 +244,16 @@ grub_util_biosdisk_open (const char *nam
 
     close (fd);
 
-#if defined (__APPLE__)
+# if defined (__APPLE__)
     disk->total_sectors = nr;
-#else
+# elif defined(__NetBSD__)
+    disk->total_sectors = label.d_secperunit;
+# else
     disk->total_sectors = nr / 512;
 
     if (nr % 512)
       grub_util_error ("unaligned device size");
-#endif
+# endif
 
     grub_util_info ("the size of %s is %llu", name, disk->total_sectors);
 
@@ -683,7 +705,7 @@ make_device_name (int drive, int dos_par
     dos_part_str = xasprintf (",%d", dos_part + 1);
 
   if (bsd_part >= 0)
-    bsd_part_str = xasprintf (",%c", dos_part + 'a');
+    bsd_part_str = xasprintf (",%c", bsd_part + 'a');
 
   ret = xasprintf ("%s%s%s", map[drive].drive,
                    dos_part_str ? : "",
@@ -853,6 +875,28 @@ convert_system_partition_to_system_disk 
     }
   return path;
 
+#elif defined(__NetBSD__)
+  /* NetBSD uses "/dev/r[wsc]d[0-9]+[a-z]".  */
+  char *path = xstrdup (os_dev);
+  if (strncmp ("/dev/rwd", path, 8) == 0 ||
+      strncmp ("/dev/rsd", path, 8) == 0 ||
+      strncmp ("/dev/rcd", path, 8) == 0)
+    {
+      char *q;
+      q = path + strlen(path) - 1;    /* last character */
+      if (grub_isalpha(*q) && grub_isdigit(*(q-1)))
+        {
+          int rawpart;
+# ifdef HAVE_GETRAWPARTITION
+          rawpart = getrawpartition();
+          if (rawpart < 0)
+# endif /* HAVE_GETRAWPARTITION */
+            rawpart = 3;    /* default on i386 */
+          *q = 'a' + rawpart;
+        }
+    }
+  return path;
+
 #else
 # warning "The function `convert_system_partition_to_system_disk' might not work on your OS correctly."
   return xstrdup (os_dev);
@@ -923,7 +967,7 @@ grub_util_biosdisk_get_grub_dev (const c
       == 0)
     return make_device_name (drive, -1, -1);
 
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__APPLE__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__APPLE__) || defined(__NetBSD__)
   if (! S_ISCHR (st.st_mode))
 #else
   if (! S_ISBLK (st.st_mode))
@@ -1107,6 +1151,133 @@ grub_util_biosdisk_get_grub_dev (const c
     return make_device_name (drive, dos_part, bsd_part);
   }
 
+#elif defined(__NetBSD__)
+  /* NetBSD uses "/dev/r[wsc]d[0-9]+[a-z]".  */
+  /* Adaptation of the Linux code above.
+     Here, get the start sector of a partition from the disklabel, and
+     compare it with each partition GRUB recognizes.  */
+  {
+    char *name;
+    grub_disk_t disk;
+    int fd;
+    struct disklabel label;
+    int index;
+    u_int32_t p_offset;
+    int dos_part = -1;
+    int bsd_part = -1;
+    auto int find_partition (grub_disk_t disk,
+			     const grub_partition_t partition);
+
+    int find_partition (grub_disk_t disk __attribute__ ((unused)),
+			const grub_partition_t partition)
+      {
+ 	struct grub_msdos_partition *pcdata = NULL;
+
+	if (strcmp (partition->partmap->name, "part_msdos") == 0)
+	  pcdata = partition->data;
+
+	if (pcdata)
+	  {
+	    if (pcdata->bsd_part < 0)
+	      grub_util_info ("DOS partition %d starts from %lu",
+			      pcdata->dos_part, partition->start);
+	    else
+	      grub_util_info ("BSD partition %d,%c starts from %lu",
+			      pcdata->dos_part, pcdata->bsd_part + 'a',
+			      partition->start);
+	  }
+	else
+	  {
+	      grub_util_info ("Partition %d starts from %lu",
+			      partition->index, partition->start);
+	  }
+
+	if (p_offset == partition->start)
+	  {
+	    if (pcdata)
+	      {
+		dos_part = pcdata->dos_part;
+		bsd_part = pcdata->bsd_part;
+	      }
+	    else
+	      {
+		dos_part = partition->index;
+		bsd_part = -1;
+	      }
+	    return 1;
+	  }
+
+	return 0;
+      }
+
+    name = make_device_name (drive, -1, -1);
+
+    /*
+     * Since os_dev and convert_system_partition_to_system_disk (os_dev) are
+     * different, we know that os_dev is of the form /dev/[wsc]d[0-9]+[a-z].
+     */
+
+    index = os_dev[strlen(os_dev) - 1] - 'a';
+
+    fd = open (os_dev, O_RDONLY);
+    if (fd == -1)
+      {
+	grub_error (GRUB_ERR_BAD_DEVICE, "cannot open `%s' while attempting to get disk label", os_dev);
+	free (name);
+	return 0;
+      }
+
+    if (ioctl (fd, DIOCGDINFO, &label))
+      {
+	grub_error (GRUB_ERR_BAD_DEVICE,
+		    "cannot get disk label of `%s'", os_dev);
+	close (fd);
+	free (name);
+	return 0;
+      }
+
+    close (fd);
+
+    if (index >= label.d_npartitions)
+      {
+	grub_error (GRUB_ERR_BAD_DEVICE,
+		    "no disk label entry for `%s'", os_dev);
+	close (fd);
+	free (name);
+	return 0;
+      }
+
+    p_offset = label.d_partitions[index].p_offset;
+    grub_util_info ("%s starts from %lu", os_dev, p_offset);
+
+    if (p_offset == 0)
+      return name;    /* use whole disk */
+
+    grub_util_info ("opening the device %s", name);
+    disk = grub_disk_open (name);
+    free (name);
+
+    if (! disk)
+      return 0;
+
+    grub_partition_iterate (disk, find_partition);
+    if (grub_errno != GRUB_ERR_NONE)
+      {
+	grub_disk_close (disk);
+	return 0;
+      }
+
+    if (dos_part < 0)
+      {
+	grub_disk_close (disk);
+	grub_error (GRUB_ERR_BAD_DEVICE,
+		    "cannot find the partition of `%s'", os_dev);
+	return 0;
+      }
+
+    return make_device_name (drive, dos_part, bsd_part);
+  }
+
 #else
 # warning "The function `grub_util_biosdisk_get_grub_dev' might not work on your OS correctly."
   return make_device_name (drive, -1, -1);
--- configure.ac.orig	2010-01-02 14:42:26.000000000 +0100
+++ configure.ac
@@ -208,6 +208,20 @@ AC_CHECK_FUNCS(memmove sbrk strdup lstat
 AC_CHECK_HEADERS(sys/mkdev.h sys/sysmacros.h malloc.h termios.h sys/types.h)
 AC_CHECK_HEADERS(unistd.h string.h strings.h sys/stat.h sys/fcntl.h)
 
+# For opendisk() and getrawpartition() on NetBSD.
+# Used in util/deviceiter.c and in util/hostdisk.c.
+AC_CHECK_HEADER([util.h], [
+  AC_CHECK_LIB([util], [opendisk], [
+    LIBUTIL="-lutil"
+    AC_DEFINE(HAVE_OPENDISK, 1, [Define if opendisk() in -lutil can be used])
+  ])
+  AC_CHECK_LIB([util], [getrawpartition], [
+    LIBUTIL="-lutil"
+    AC_DEFINE(HAVE_GETRAWPARTITION, 1, [Define if getrawpartition() in -lutil can be used])
+  ])
+])
+AC_SUBST([LIBUTIL])
+
 #
 # Check for target programs.
 #
--- Makefile.in.orig	2010-01-02 14:42:01.000000000 +0100
+++ Makefile.in
@@ -44,6 +44,9 @@ pkglibdir =  $(libdir)/`echo @PACKAGE_TA
 # Internationalization library.
 LIBINTL = @LIBINTL@
 
+# Util library.
+LIBUTIL = @LIBUTIL@
+
 XGETTEXT = @XGETTEXT@
 MSGMERGE = @MSGMERGE@
 MSGFMT = @MSGFMT@
@@ -75,7 +78,7 @@ MKDIR_P = @MKDIR_P@
 
 mkinstalldirs = $(srcdir)/mkinstalldirs
 
-LIBS = @LIBS@ $(LIBINTL)
+LIBS = @LIBS@ $(LIBINTL) $(LIBUTIL)
 
 CC = @CC@
 CFLAGS = @CFLAGS@
