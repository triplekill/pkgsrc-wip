$NetBSD$

--- GL/glx/glxdri.c.orig	2007-04-09 15:59:09.000000000 -0400
+++ GL/glx/glxdri.c
@@ -327,6 +327,22 @@ __glXDRIbindTexImage(__GLXcontext *baseC
     int		bpp;
     GLenum	target, format, type;
 
+    /* When the GLX_EXT_texture_from_pixmap is used, as it's
+     * implemented here, we want to pull pixmap out of video memory
+     * and into host memory. */
+    {
+      extern void XAAEvictPixmaps(void);
+      static int evictedPixmaps = 0;
+
+      if (!evictedPixmaps) {
+	__glXDRIenterServer();
+	if (dlsym(RTLD_DEFAULT, "XAAEvictPixmaps"))
+	    XAAEvictPixmaps();
+	__glXDRIleaveServer();
+	evictedPixmaps = TRUE;
+      }
+    }
+
     pixmap = (PixmapPtr) glxPixmap->pDraw;
     if (!glxPixmap->pDamage) {
         glxPixmap->pDamage = DamageCreate(NULL, NULL, DamageReportNone,
@@ -752,8 +768,32 @@ getDrawableInfo(__DRInativeDisplay *dpy,
     if (*numClipRects > 0) {
 	size = sizeof (drm_clip_rect_t) * *numClipRects;
 	*ppClipRects = xalloc (size);
-	if (*ppClipRects != NULL)
-	    memcpy (*ppClipRects, pClipRects, size);
+
+	/* Clip cliprects to screen dimensions (redirected windows) */
+	if (*ppClipRects != NULL) {
+	    ScreenPtr pScreen = screenInfo.screens[screen];
+	    int i, j;
+
+	    for (i = 0, j = 0; i < *numClipRects; i++) {
+	        (*ppClipRects)[j].x1 = max(pClipRects[i].x1, 0);
+		(*ppClipRects)[j].y1 = max(pClipRects[i].y1, 0);
+		(*ppClipRects)[j].x2 = min(pClipRects[i].x2, pScreen->width);
+		(*ppClipRects)[j].y2 = min(pClipRects[i].y2, pScreen->height);
+
+		if ((*ppClipRects)[j].x1 < (*ppClipRects)[j].x2 &&
+		    (*ppClipRects)[j].y1 < (*ppClipRects)[j].y2) {
+		    j++;
+		}
+	    }
+
+	    if (*numClipRects != j) {
+		*numClipRects = j;
+		*ppClipRects = xrealloc (*ppClipRects,
+					 sizeof (drm_clip_rect_t) *
+					 *numClipRects);
+	    }
+	} else
+	    *numClipRects = 0;
     }
     else {
       *ppClipRects = NULL;
