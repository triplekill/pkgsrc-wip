$NetBSD$

--- src/card_direct.c.orig	2003-02-03 22:53:29.000000000 +0100
+++ src/card_direct.c
@@ -43,10 +43,9 @@
 #include <errno.h>
 #include <fcntl.h>
 
-#include <pci/pci.h>
+#include <pciutils/pci.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
-#include <sys/io.h>
 
 #include "backend.h"
 #include "card_direct.h"
@@ -114,6 +113,56 @@ void unmapDevMem (unsigned long Base, un
 
 /* -------- Common -------- */
 
+#ifdef __NetBSD__
+static int
+ioperm(from, num, turn_on)
+	unsigned long from;
+	unsigned long num;
+	int turn_on;
+{
+	u_long *bitmap, mask, value;
+	int r = -1;
+	int first_index, last_index, i;
+
+	if((bitmap = (u_long *)malloc(1024*sizeof(u_long))) == NULL)
+		return -1;
+
+	if(i386_get_ioperm(bitmap) != 0)
+		goto ioperm_fail;
+
+	first_index = from / 32;
+	last_index = (from + num) / 32;
+
+	/* First set */
+	mask = 0xffffffff << (from % 32);
+	if(turn_on)
+		bitmap[first_index] |= mask;
+	else
+		bitmap[first_index] &= ~mask;
+
+	/* Last set */
+	mask = 0xffffffff >> (31 - (from + num) % 32);
+	if(turn_on)
+		bitmap[last_index] |= mask;
+	else
+		bitmap[last_index] &= ~mask;
+
+	if(last_index > first_index + 1) {
+		/* Complete sets */
+		value = turn_on ? 0xffffffff : 0;
+
+		for(i = first_index+1; i<last_index; i++)
+			bitmap[i] = value;
+	}
+
+	r = i386_set_ioperm(bitmap);
+
+ioperm_fail:
+	free(bitmap);
+	return r;
+}
+#endif
+
 /*
  * Test if card is supported, and create entry for it if it is.
  */
@@ -142,7 +191,7 @@ void test_card (CardPtr *card_list, char
 	type = CARD_XBOX;
 	/* FIXME get PIO base from device w/ id 01B4 (SMBus controller) */
 	pio_base = 0xC000;
-	iopl (3);
+	i386_iopl (3);
       }
       reg_base = base0;
       break;
