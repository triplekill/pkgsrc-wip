$NetBSD$

--- src/card_direct.c.orig	2003-05-08 17:42:44.000000000 +0200
+++ src/card_direct.c
@@ -44,8 +44,12 @@
 #include <fcntl.h>
 
 #ifdef HAVE_PCI
+#ifdef HAVE_PCIUTILS
+#include <pciutils/pci.h>
+#else
 #include <pci/pci.h>
 #endif
+#endif
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #ifdef HAVE_SYS_IO_H
@@ -164,6 +168,56 @@ void unmapDevMem (CardPtr card, unsigned
 
 /* -------- Common -------- */
 
+#ifdef __NetBSD__
+static int
+ioperm(from, num, turn_on)
+	unsigned long from;
+	unsigned long num;
+	int turn_on;
+{
+	u_long *bitmap, mask, value;
+	int r = -1;
+	int first_index, last_index, i;
+
+	if((bitmap = (u_long *)malloc(1024*sizeof(u_long))) == NULL)
+		return -1;
+
+	if(i386_get_ioperm(bitmap) != 0)
+		goto ioperm_fail;
+
+	first_index = from / 32;
+	last_index = (from + num) / 32;
+
+	/* First set */
+	mask = 0xffffffff << (from % 32);
+	if(turn_on)
+		bitmap[first_index] |= mask;
+	else
+		bitmap[first_index] &= ~mask;
+
+	/* Last set */
+	mask = 0xffffffff >> (31 - (from + num) % 32);
+	if(turn_on)
+		bitmap[last_index] |= mask;
+	else
+		bitmap[last_index] &= ~mask;
+
+	if(last_index > first_index + 1) {
+		/* Complete sets */
+		value = turn_on ? 0xffffffff : 0;
+
+		for(i = first_index+1; i<last_index; i++)
+			bitmap[i] = value;
+	}
+
+	r = i386_set_ioperm(bitmap);
+
+ioperm_fail:
+	free(bitmap);
+	return r;
+}
+#endif
+
 /*
  * Test if card is supported, and create entry for it if it is.
  */
@@ -193,8 +247,12 @@ void test_card (CardPtr *card_list, char
 	/* FIXME get PIO base from device w/ id 01B4 (SMBus controller) */
 	pio_base = 0xC000;
 #ifndef HAVE_WINIO
+#ifdef __NetBSD__
+	i386_iopl (3);
+#else
 	iopl (3);
 #endif
+#endif
       }
       reg_base = base0;
       break;
