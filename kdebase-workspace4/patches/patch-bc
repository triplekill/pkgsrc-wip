$NetBSD$

--- ksysguard/ksysguardd/NetBSD/CPU.c.orig	2007-10-17 03:44:42.000000000 +1300
+++ ksysguard/ksysguardd/NetBSD/CPU.c
@@ -19,10 +19,11 @@
 
 */
 
+#include <sys/param.h>
+#include <sys/sysctl.h>
 #include <sys/dkstat.h>
 #include <sys/sched.h>         /* CPUSTATES */
 #include <fcntl.h>
-#include <kvm.h>
 #include <nlist.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,20 +34,11 @@
 #include "Command.h"
 #include "ksysguardd.h"
 
-long percentages(int cnt, int *out, long *new, long *old, long *diffs);
+void percentages(int, int *, u_int64_t *, u_int64_t *, u_int64_t *);
 
-struct nlist my_nlist[] = {
-	{"_cp_time"},
-	{ 0 }
-};
-
-kvm_t *kd;
-
-unsigned long cp_time_offset;
-
-long cp_time[CPUSTATES];
-long cp_old[CPUSTATES];
-long cp_diff[CPUSTATES];
+u_int64_t cp_time[CPUSTATES];
+u_int64_t cp_old[CPUSTATES];
+u_int64_t cp_diff[CPUSTATES];
 int cpu_states[CPUSTATES];
 
 void
@@ -57,17 +49,17 @@ initCpuInfo(struct SensorModul* sm)
 	registerMonitor("cpu/system/nice", "integer", printCPUNice, printCPUNiceInfo, sm);
 	registerMonitor("cpu/system/sys", "integer", printCPUSys, printCPUSysInfo, sm);
 	registerMonitor("cpu/system/idle", "integer", printCPUIdle, printCPUIdleInfo, sm);
+	registerMonitor("cpu/system/interrupt", "integer", printCPUIntr, printCPUIntrInfo, sm);
+	/* linux compat */
+	registerMonitor("cpu/system/wait", "integer", printCPUWait, printCPUWaitInfo, sm);
 	
 	/* Monitor names changed from kde3 => kde4. Remain compatible with legacy requests when possible. */
 	registerLegacyMonitor("cpu/user", "integer", printCPUUser, printCPUUserInfo, sm);
 	registerLegacyMonitor("cpu/nice", "integer", printCPUNice, printCPUNiceInfo, sm);
 	registerLegacyMonitor("cpu/sys", "integer", printCPUSys, printCPUSysInfo, sm);
 	registerLegacyMonitor("cpu/idle", "integer", printCPUIdle, printCPUIdleInfo, sm);
+	registerMonitor("cpu/wait", "integer", printCPUWait, printCPUWaitInfo, sm);
 	
-	kd = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open");
-	kvm_nlist(kd, my_nlist);
-	cp_time_offset = my_nlist[0].n_value;
-
 	updateCpuInfo();
 }
 
@@ -78,21 +70,27 @@ exitCpuInfo(void)
 	removeMonitor("cpu/system/nice");
 	removeMonitor("cpu/system/sys");
 	removeMonitor("cpu/system/idle");
+	removeMonitor("cpu/system/interrupt");
+	removeMonitor("cpu/system/wait");
 
 	/* These were registered as legacy monitors */
 	removeMonitor("cpu/user");
 	removeMonitor("cpu/nice");
 	removeMonitor("cpu/sys");
 	removeMonitor("cpu/idle");
-
-
-	kvm_close(kd);
+	removeMonitor("cpu/wait");
 }
 
 int
 updateCpuInfo(void)
 {
-        kvm_read(kd, cp_time_offset, (char *)cp_time, sizeof(cp_time));
+	int mib[2];
+	size_t size;
+
+	mib[0] = CTL_KERN;
+        mib[1] = KERN_CP_TIME;
+	size = sizeof(cp_time[0]) * CPUSTATES;
+	sysctl(mib, 2, cp_time, &size, NULL, 0);
         percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
 	return (0);
 }
@@ -145,6 +143,30 @@ printCPUIdleInfo(const char* cmd)
 	fprintf(CurrentClient, "CPU Idle Load\t0\t100\t%%\n");
 }
 
+void
+printCPUIntr(const char* cmd)
+{
+	fprintf(CurrentClient, "%d\n", cpu_states[CP_INTR]/10);
+}
+
+void
+printCPUIntrInfo(const char* cmd)
+{
+	fprintf(CurrentClient, "CPU Interrupt Load\t0\t100\t%%\n");
+}
+
+
+void
+printCPUWait(const char* cmd)
+{
+	fprintf(CurrentClient, "0\n");
+}
+
+void
+printCPUWaitInfo(const char* cmd)
+{
+	fprintf(CurrentClient, "CPU Wait Load\t0\t100\t%%\n");
+}
 
 /* The part ripped from top... */
 /*
@@ -167,20 +189,20 @@ printCPUIdleInfo(const char* cmd)
  *	useful on BSD mchines for calculating cpu state percentages.
  */
 
-long percentages(cnt, out, new, old, diffs)
+void percentages(cnt, out, new, old, diffs)
 
 int cnt;
 int *out;
-register long *new;
-register long *old;
-long *diffs;
+u_int64_t *new;
+u_int64_t *old;
+u_int64_t *diffs;
 
 {
-    register int i;
-    register long change;
-    register long total_change;
-    register long *dp;
-    long half_total;
+    int i;
+    u_int64_t change;
+    u_int64_t total_change;
+    u_int64_t *dp;
+    u_int64_t half_total;
 
     /* initialization */
     total_change = 0;
@@ -189,12 +211,11 @@ long *diffs;
     /* calculate changes for each state and the overall change */
     for (i = 0; i < cnt; i++)
     {
-	if ((change = *new - *old) < 0)
-	{
-	    /* this only happens when the counter wraps */
-	    change = (int)
-		((unsigned long)*new-(unsigned long)*old);
-	}
+        /*
+	 * Don't worry about wrapping - even at hz=1GHz, a
+	 * u_int64_t will last at least 544 years.
+	 */
+        change = *new - *old;
 	total_change += (*dp++ = change);
 	*old++ = *new++;
     }
@@ -206,16 +227,9 @@ long *diffs;
     }
 
     /* calculate percentages based on overall change, rounding up */
-    half_total = total_change / 2l;
-
-    /* Do not divide by 0. Causes Floating point exception */
-    if(total_change) {
-        for (i = 0; i < cnt; i++)
-        {
-          *out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
-        }
+    half_total = total_change / 2;
+    for (i = 0; i < cnt; i++)
+    {
+        *out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
     }
-
-    /* return the total in case the caller wants to use it */
-    return(total_change);
 }
